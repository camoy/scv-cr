#lang typed/racket/no-check
(require racket/contract
          (lib "racket/contract.rkt")
          (lib "racket/base.rkt")
          (lib "racket/contract/base.rkt")
          (submod (lib "typed-racket/private/type-contract.rkt") predicates))
(define g80 (lambda (x) (automaton? x)))
(define g81 nonnegative?)
(define g82 (or/c g81))
(define g83 exact-nonnegative-integer?)
(define g84 (or/c g83))
(define generated-contract71 (-> g80 (values g82)))
(define generated-contract72 (-> g80 (values g80)))
(define generated-contract73 (-> g80 (values g80)))
(define generated-contract74 (-> g82 (values g80)))
(define generated-contract75 (-> g82 (values g80)))
(define generated-contract76 (-> g82 (values g80)))
(define generated-contract77 (-> g84 (values g80)))
(define generated-contract78 (-> g80 g80 g84 (values g80 g80)))
(define generated-contract79 (-> g82 (values g80)))
(module require/contracts racket/base (require racket/contract) (provide))
(require (prefix-in -: (only-in 'require/contracts))
          (except-in 'require/contracts))
(define-values () (values))
(define-type Automaton automaton)
(define-type Payoff Nonnegative-Real)
(void)
(: defects (-> Payoff Automaton))
(: cooperates (-> Payoff Automaton))
(: tit-for-tat (-> Payoff Automaton))
(: grim-trigger (-> Payoff Automaton))
(: make-random-automaton (-> Natural Automaton))
(: match-pair (-> Automaton Automaton Natural (values Automaton Automaton)))
(: automaton-reset (-> Automaton Automaton))
(: clone (-> Automaton Automaton))
(: COOPERATE State)
(define COOPERATE 0)
(: DEFECT State)
(define DEFECT 1)
(define-type State Natural)
(define-type Transition* (Vectorof Transition))
(define-type Transition (Vectorof State))
(struct
  automaton
  ((current : State)
   (original : State)
   (payoff : Payoff)
   (table : Transition*))
  #:transparent)
(define (make-random-automaton n)
   (: transitions (-> Any Transition))
   (define (transitions _i) (build-vector n (lambda (_) (random n))))
   (define original-current (random n))
   (automaton
    original-current
    original-current
    0
    (build-vector n transitions)))
(: make-automaton (-> State Transition* Automaton))
(define (make-automaton current table) (automaton current current 0 table))
(: transitions (-> State State State State Transition*))
(define (transitions cc cd dc dd) (vector (vector cc cd) (vector dc dd)))
(define defect-transitions (transitions DEFECT DEFECT DEFECT DEFECT))
(define (defects p0) (automaton DEFECT DEFECT p0 defect-transitions))
(define cooperates-transitions
   (transitions COOPERATE COOPERATE COOPERATE COOPERATE))
(define (cooperates p0)
   (automaton COOPERATE COOPERATE p0 cooperates-transitions))
(define tit-for-tat-transitions
   (transitions COOPERATE DEFECT COOPERATE DEFECT))
(define (tit-for-tat p0)
   (automaton COOPERATE COOPERATE p0 tit-for-tat-transitions))
(define grim-transitions (transitions COOPERATE DEFECT DEFECT DEFECT))
(: grim-trigger (-> Payoff Automaton))
(define (grim-trigger p0) (automaton COOPERATE COOPERATE p0 grim-transitions))
(define (automaton-reset a)
   (match-define (automaton current c0 payoff table) a)
   (automaton c0 c0 0 table))
(define (clone a)
   (match-define (automaton current c0 payoff table) a)
   (automaton c0 c0 0 table))
(define (match-pair auto1 auto2 rounds-per-match)
   (match-define (automaton current1 c1 payoff1 table1) auto1)
   (match-define (automaton current2 c2 payoff2 table2) auto2)
   (define-values
    (new1 p1 new2 p2)
    (for/fold
     ((current1 : State current1)
      (payoff1 : Payoff payoff1)
      (current2 : State current2)
      (payoff2 : Payoff payoff2))
     ((_ (in-range rounds-per-match)))
     (match-define (cons p1 p2) (payoff current1 current2))
     (define n1 (vector-ref (vector-ref table1 current1) current2))
     (define n2 (vector-ref (vector-ref table2 current2) current1))
     (values n1 (+ payoff1 p1) n2 (+ payoff2 p2))))
   (values (automaton new1 c1 p1 table1) (automaton new2 c2 p2 table2)))
(: PAYOFF-TABLE (Vectorof (Vectorof (cons Payoff Payoff))))
(define PAYOFF-TABLE
   (vector (vector (cons 3 3) (cons 0 4)) (vector (cons 4 0) (cons 1 1))))
(: payoff (-> State State (cons Payoff Payoff)))
(define (payoff current1 current2)
   (vector-ref (vector-ref PAYOFF-TABLE current1) current2))
(provide automaton-payoff Automaton)
(provide (contract-out (defects generated-contract75))
          (contract-out (clone generated-contract73))
          (contract-out (automaton-reset generated-contract72))
          (contract-out (match-pair generated-contract78))
          (contract-out (make-random-automaton generated-contract77))
          (contract-out (grim-trigger generated-contract76))
          (contract-out (tit-for-tat generated-contract79))
          (contract-out (cooperates generated-contract74)))
