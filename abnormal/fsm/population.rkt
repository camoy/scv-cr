#lang typed/racket/no-check
(require racket/contract
          (lib "racket/contract.rkt")
          (lib "racket/base.rkt")
          (lib "racket/contract/base.rkt")
          (submod (lib "typed-racket/private/type-contract.rkt") predicates)
          (submod "automata.rkt" #%type-decl ".."))
(define g23 exact-nonnegative-integer?)
(define g24 (or/c g23))
(define g25 (lambda (x) (automaton? x)))
(define g26 (vectorof g25))
(define g27 (or/c g26))
(define g28 (cons/c g27 g27))
(define g29 real?)
(define g30 '#f)
(define g31 (or/c g29 g30))
(define g32 nonnegative?)
(define g33 (or/c g32))
(define g34 (listof g33))
(define generated-contract19 (-> g24 (values g28)))
(define generated-contract20
   (case-> (-> g28 g24 (values g28)) (-> g28 g24 g31 (values g28))))
(define generated-contract21 (-> g28 g24 (values g28)))
(define generated-contract22 (-> g28 (values g34)))
(module require/contracts racket/base (require racket/contract) (provide))
(require (prefix-in -: (only-in 'require/contracts))
          (except-in 'require/contracts))
(define-values () (values))
(void)
(: build-random-population (-> Natural Population))
(: population-payoffs (-> Population (Listof Payoff)))
(: match-up* (-> Population Natural Population))
(: death-birth (->* (Population Natural) ((U False Real)) Population))
(require require-typed-check "automata-adapted.rkt")
(require "utilities.rkt")
(define DEF-COO 2)
(define (build-random-population n)
   (define v (build-vector n (lambda (_) (make-random-automaton DEF-COO))))
   (cons v v))
(define (population-payoffs population0)
   (define population (car population0))
   (for/list ((a population)) (automaton-payoff a)))
(define (match-up* population0 rounds-per-match)
   (define a* (car population0))
   (population-reset a*)
   (for
    ((i (in-range 0 (- (vector-length a*) 1) 2)))
    (define p1 (vector-ref a* i))
    (define p2 (vector-ref a* (+ i 1)))
    (define-values (a1 a2) (match-pair p1 p2 rounds-per-match))
    (vector-set! a* i a1)
    (vector-set! a* (+ i 1) a2))
   population0)
(: population-reset (-> Automaton* Void))
(define (population-reset a*)
   (for
    ((x (in-list (vector->list a*))) (i (in-naturals)))
    (vector-set! a* i (automaton-reset x))))
(define (death-birth population0 rate (q #f))
   (match-define (cons a* b*) population0)
   (define payoffs
     (for/list
      :
      (Listof Payoff)
      ((x : Automaton (in-list (vector->list a*))))
      (automaton-payoff x)))
   (define substitutes (choose-randomly payoffs rate q))
   (for
    ((i (in-range rate)) (p (in-list substitutes)))
    (vector-set! a* i (clone (vector-ref b* p))))
   (shuffle-vector a* b*))
(:
  shuffle-vector
  (All (X) (-> (Vectorof X) (Vectorof X) (cons (Vectorof X) (Vectorof X)))))
(define (shuffle-vector b a)
   (for ((x (in-list (vector->list b))) (i (in-naturals))) (vector-set! a i x))
   (for
    ((x (in-list (vector->list b))) (i (in-naturals)))
    (define j (random (add1 i)))
    (unless (= j i) (vector-set! a i (vector-ref a j)))
    (vector-set! a j x))
   (cons a b))
(provide)
(provide (contract-out (match-up* generated-contract21))
          (contract-out (population-payoffs generated-contract22))
          (contract-out (build-random-population generated-contract19))
          (contract-out (death-birth generated-contract20)))
