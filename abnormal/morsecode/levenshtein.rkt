#lang typed/racket/base/no-check
(require racket/contract
          (lib "racket/contract.rkt")
          (lib "racket/base.rkt")
          (lib "racket/contract/base.rkt")
          (lib "typed-racket/types/numeric-predicates.rkt"))
(define g16 string?)
(define g17 char?)
(define g18 (listof g17))
(define g19 (vectorof g17))
(define g20 (or/c g16 g18 g19))
(define g21 t:index?)
(define g22 (or/c g21))
(define g23 '#t)
(define g24 '#f)
(define g25 (or/c g23 g24))
(define g26 (-> g17 g17 (values g25)))
(define g27 (or/c g19))
(define g28 exact-integer?)
(define g29 (or/c g28))
(define g30 (vectorof g22))
(define g31 (or/c g30))
(define g32 (-> g29 (values g31)))
(define generated-contract3 (-> g20 g20 (values g22)))
(define generated-contract4 (-> g18 g18 (values g22)))
(define generated-contract5 (-> g18 g18 (values g22)))
(define generated-contract6 (-> g18 g18 (values g22)))
(define generated-contract7 (-> g18 g18 (values g22)))
(define generated-contract8 (-> g18 g18 g26 (values g22)))
(define generated-contract9 (-> g16 g16 (values g22)))
(define generated-contract10 (-> g27 g27 (values g22)))
(define generated-contract11 (-> g27 g27 (values g22)))
(define generated-contract12 (-> g27 g27 (values g22)))
(define generated-contract13 (-> g27 g27 (values g22)))
(define generated-contract14 (-> g27 g27 g26 (values g22)))
(define generated-contract15 (-> g27 g27 g26 g32 (values g22)))
(module require/contracts racket/base (require racket/contract) (provide))
(require (prefix-in -: (only-in 'require/contracts))
          (except-in 'require/contracts))
(define-values () (values))
(: %identity (All (A) (-> A A)))
(define (%identity x) x)
(: %string-empty? (-> String Boolean))
(define (%string-empty? v) (zero? (string-length v)))
(: %vector-empty? (-> (Vectorof Char) Boolean))
(define (%vector-empty? v) (zero? (vector-length v)))
(: %string->vector (-> String (Vectorof Char)))
(define (%string->vector s) (list->vector (string->list s)))
(:
  vector-levenshtein/predicate/get-scratch
  (->
   (Vectorof Char)
   (Vectorof Char)
   (-> Char Char Boolean)
   (-> Integer (Vectorof Index))
   Index))
(define (vector-levenshtein/predicate/get-scratch a b pred get-scratch)
   (let:
    ((a-len : Index (vector-length a)) (b-len : Index (vector-length b)))
    (cond
     ((zero? a-len) b-len)
     ((zero? b-len) a-len)
     (else
      (let:
       ((w : (Vectorof Index) (get-scratch (+ 1 b-len))) (next : Index 0))
       (let fill ((k b-len))
         (unless (index? k) (error "vl/p/g invariant error"))
         (vector-set! w k k)
         (or (zero? k) (fill (- k 1))))
       (let loop-i ((i 0))
         (if (= i a-len)
           next
           (let ((a-i (vector-ref a i)))
             (let loop-j ((j 0) (cur (+ 1 i)))
               (if (= j b-len)
                 (begin (vector-set! w b-len next) (loop-i (+ 1 i)))
                 (let ((next*
                        (min
                         (+ 1 (vector-ref w (+ 1 j)))
                         (+ 1 cur)
                         (if (pred a-i (vector-ref b j))
                           (vector-ref w j)
                           (+ 1 (vector-ref w j))))))
                   (unless (index? next*) (error "invariant"))
                   (set! next next*)
                   (unless (index? cur) (error "invariant error"))
                   (vector-set! w j cur)
                   (loop-j (+ 1 j) next))))))))))))
(:
  vector-levenshtein/predicate
  (-> (Vectorof Char) (Vectorof Char) (-> Char Char Boolean) Index))
(define (vector-levenshtein/predicate a b pred)
   (vector-levenshtein/predicate/get-scratch a b pred make-vector))
(: vector-levenshtein/eq (-> (Vectorof Char) (Vectorof Char) Index))
(define (vector-levenshtein/eq a b) (vector-levenshtein/predicate a b eq?))
(: vector-levenshtein/eqv (-> (Vectorof Char) (Vectorof Char) Index))
(define (vector-levenshtein/eqv a b) (vector-levenshtein/predicate a b eqv?))
(: vector-levenshtein/equal (-> (Vectorof Char) (Vectorof Char) Index))
(define (vector-levenshtein/equal a b)
   (vector-levenshtein/predicate a b equal?))
(: vector-levenshtein (-> (Vectorof Char) (Vectorof Char) Index))
(define (vector-levenshtein a b) (vector-levenshtein/equal a b))
(:
  list-levenshtein/predicate
  (-> (Listof Char) (Listof Char) (-> Char Char Boolean) Index))
(define (list-levenshtein/predicate a b pred)
   (cond
    ((null? a) (length b))
    ((null? b) (length a))
    (else
     (vector-levenshtein/predicate (list->vector a) (list->vector b) pred))))
(: list-levenshtein/eq (-> (Listof Char) (Listof Char) Index))
(define (list-levenshtein/eq a b) (list-levenshtein/predicate a b eq?))
(: list-levenshtein/eqv (-> (Listof Char) (Listof Char) Index))
(define (list-levenshtein/eqv a b) (list-levenshtein/predicate a b eqv?))
(: list-levenshtein/equal (-> (Listof Char) (Listof Char) Index))
(define (list-levenshtein/equal a b) (list-levenshtein/predicate a b equal?))
(: list-levenshtein (-> (Listof Char) (Listof Char) Index))
(define (list-levenshtein a b) (list-levenshtein/equal a b))
(: string-levenshtein (-> String String Index))
(define (string-levenshtein a b)
   (cond
    ((zero? (string-length a)) (string-length b))
    ((zero? (string-length b)) (string-length a))
    (else (vector-levenshtein/eqv (%string->vector a) (%string->vector b)))))
(:
  %string-levenshtein/predicate
  (-> String String (-> Char Char Boolean) Index))
(define (%string-levenshtein/predicate a b pred)
   (cond
    ((zero? (string-length a)) (string-length b))
    ((zero? (string-length b)) (string-length a))
    (else
     (vector-levenshtein/predicate
      (%string->vector a)
      (%string->vector b)
      pred))))
(define-type LType (U (Vectorof Char) String (Listof Char)))
(: levenshtein (-> LType LType Index))
(define (levenshtein a b)
   (cond
    ((and (string? a) (string? b)) (string-levenshtein a b))
    ((and (vector? a) (vector? b)) (vector-levenshtein a b))
    ((and (list? a) (list? b)) (list-levenshtein a b))
    (else (error "levenshtein"))))
(void)
(provide)
(provide (contract-out (list-levenshtein/equal generated-contract6))
          (contract-out (levenshtein generated-contract3))
          (contract-out (list-levenshtein/eqv generated-contract7))
          (contract-out (list-levenshtein generated-contract4))
          (contract-out (list-levenshtein/predicate generated-contract8))
          (contract-out (list-levenshtein/eq generated-contract5))
          (contract-out (string-levenshtein generated-contract9))
          (contract-out (vector-levenshtein generated-contract10))
          (contract-out (vector-levenshtein/predicate generated-contract14))
          (contract-out (vector-levenshtein/eq generated-contract11))
          (contract-out
           (vector-levenshtein/predicate/get-scratch generated-contract15))
          (contract-out (vector-levenshtein/equal generated-contract12))
          (contract-out (vector-levenshtein/eqv generated-contract13)))
