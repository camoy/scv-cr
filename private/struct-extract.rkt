#lang racket/base

(require racket/list
         racket/set
         racket/syntax
         racket/string
         racket/function
         mischief/dict
         syntax/parse)

;; A Struct-Hash is a [Hash Symbol [Hash Syntax Syntax]]
;; mapping struct identifier to a mapping between fields
;; and contracts.

;; A Struct-Proc is a (Symbol [List-of Symbol] -> [List-of Symbol])
;; Returns some subset of all the exports generated by a
;; struct definition.

;;
;; struct munging
;;

(provide struct-munge!)

;; P/C-Hash I/C-Hash Syntax -> Syntax
;; takes an mapping between exports and contract definitions, the entire
;; program source, and mapping between
(define (struct-munge! p/c-hash i/c-hash stx-raw)
  (let* ([name->fields (extract-structs stx-raw)]
         [export?      (struct-export? name->fields)]
         [accessor?    (struct-accessor? name->fields)]
         [struct-hash  (make-hash (hash-map name->fields
                                            (λ (name _)
                                              (cons name (make-hash)))))])
    (hash-for-each
     p/c-hash
     (λ (id ctc)
       (when (export? (syntax-e id))
         (hash-remove! p/c-hash id))
       (when (accessor? (syntax-e id))
         (struct-hash-add! struct-hash id ctc i/c-hash))))
    (make-struct-out struct-hash)))

;; Struct-Hash -> [List-of Syntax]
;; returns list of struct-out declarations for contract-out
(define (make-struct-out struct-hash)
  (hash-map struct-hash
            (λ (name fld->ctc)
              #`(struct #,name #,(hash-map fld->ctc list)))))

;;
;; struct names
;;

;; Syntax -> [Hash Symbol [List-of Symbol]]
;; takes Typed Racket syntax and returns hash
;; that maps struct names to their fields
(define (extract-structs stx)
  (define name->fields
    (make-hash))
  (let go ([stx stx])
    (syntax-parse stx
      #:datum-literals (struct struct: :)
      [((~or struct struct:) name ((fld : type) ...))
       (hash-set! name->fields
                  (syntax-e #'name)
                  (syntax->datum #'(fld ...)))
       stx]
      [(x ...)
       (for-each go (syntax-e #'(x ...)))
       stx]
      [_ stx]))
  name->fields)

;; Struct-Proc
;; returns all exports
(define (struct-exports name flds)
  (append (list name
                (format-symbol "~a?" name)
                (format-symbol "struct:~a" name))
          (struct-accessors name flds)
          (struct-mutators name flds)))

;; Struct-Proc
;; returns only the accessors
(define (struct-accessors name flds)
  (map (curry format-symbol "~a-~a" name) flds))

;; Struct-Proc
;; returns only the mutators
(define (struct-mutators name flds)
  (map (curry format-symbol "set-~a-~a!" name) flds))

;; Struct-Proc [Hash Symbol Symbol] -> (Symbol -> Symbol or #f)
;; takes a Struct-Proc and name field mapping and returns
;; a function that can determine if a symbol is that kind
;; of export for the given mapping
(define ((make-struct-proc? kind) name->fields)
  (define exports
    (hash-map name->fields
              (λ (name flds)
                (map (λ (fld) (cons fld name))
                     (kind name flds)))))
  (define exports* (apply append exports))
  (dict->procedure exports* #:failure #f))

(define struct-export? (make-struct-proc? struct-exports))
(define struct-accessor? (make-struct-proc? struct-accessors))
(define struct-mutator? (make-struct-proc? struct-mutators))

;;
;; struct munging helpers
;;

;; Syntax I/C-Hash -> Syntax
;; returns co-domain of the given definition through
;; layers of definitional indirection
(define (chase-codomain i i/c-hash)
  (syntax-parse i
    #:datum-literals (->)
    [(-> _ x) #'x]
    [x        (chase-codomain (hash-ref i/c-hash i) i/c-hash)]))

;; Symbol -> Symbol
;; returns struct name and field from accessor name
(define (accessor->split id)
  (define split (string-split (symbol->string id) "-"))
  (values (string->symbol (car split))
          (string->symbol (cadr split))))

;; Syntax Syntax [Hash Syntax Syntax] Struct-Hash ->
;; takes pair matching accessor with contract and pushes
;; appropriate field-to-contract association into struct
;; hash
(define (struct-hash-add! struct-hash id ctc i/c-hash)
  (define-values (struct-name fld)
    (accessor->split (syntax-e id)))
  (define fld-ctc (chase-codomain ctc i/c-hash))
  (hash-set! (hash-ref struct-hash struct-name)
             fld
             fld-ctc))

;;
;; test struct name
;;

(module+ test
  (require rackunit)

  (define posn-hash
    (make-hash '((posn . (x y z)))))

  (test-case
    "extract-structs"
    (check-equal?
     (extract-structs
      #'(module root typed/racket/base
          (struct: posn ((x : Real) (y : Real) (z : Real)))))
     posn-hash))

  (test-case
    "struct-exports"
    (check-equal?
     (struct-exports 'posn '(x y z))
     '(posn
       posn?
       struct:posn
       posn-x posn-y posn-z
       set-posn-x! set-posn-y! set-posn-z!)))

  (define posn-export? (struct-export? posn-hash))
  (define posn-accessor? (struct-accessor? posn-hash))
  (define posn-mutator? (struct-mutator? posn-hash))

  (test-case
    "struct-export?"
    (check-equal? (posn-export? 'posn) 'posn)
    (check-equal? (posn-export? 'posn-x) 'posn)
    (check-false  (posn-export? 'posn-w))
    (check-equal? (posn-export? 'set-posn-y!) 'posn)
    (check-equal? (posn-export? 'posn?) 'posn)
    (check-equal? (posn-export? 'struct:posn) 'posn)
    )

  (test-case
    "struct-accessor?"
    (check-false  (posn-accessor? 'posn))
    (check-equal? (posn-accessor? 'posn-x) 'posn)
    (check-equal? (posn-accessor? 'posn-y) 'posn)
    (check-equal? (posn-accessor? 'posn-z) 'posn)
    (check-false  (posn-accessor? 'posn-w))
    (check-false (posn-accessor? 'set-posn-y!))
    (check-false (posn-accessor? 'posn?))
    (check-false (posn-accessor? 'struct:posn))
    )

  (test-case
    "struct-mutator?"
    (check-false  (posn-mutator? 'posn))
    (check-false (posn-mutator? 'posn-x))
    (check-false  (posn-mutator? 'posn-w))
    (check-equal? (posn-mutator? 'set-posn-x!) 'posn)
    (check-equal? (posn-mutator? 'set-posn-y!) 'posn)
    (check-equal? (posn-mutator? 'set-posn-z!) 'posn)
    (check-false (posn-mutator? 'posn?))
    (check-false (posn-mutator? 'struct:posn))
    )
  )
