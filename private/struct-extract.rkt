#lang racket/base

(require racket/require
         (multi-in racket (list set syntax string function))
         mischief/dict
         syntax/parse
         scv-gt/private/syntax-util)

;;
;; P/C-Hash functions
;;

(provide p/c-remove-structs!)

;; I/C-Hash P/C-Hash Symbol Syntax -> S/O-Hash
;; modifies p/c-hash removing struct-related exports and returns
;; s/o-hash
(define (p/c-remove-structs! i/c-hash p/c-hash key stx)
  (let* ([s/f-hash (s/f-make key stx)]
         [export?  (s/f-export? s/f-hash)]
         [ctor?    (curry unstrange s/f-hash)]
         [s/c-hash (make-hash)])
    (hash-for-each
     p/c-hash
     (λ (id ctc)
       (when (export? id)
         (hash-remove! p/c-hash id))
       (when (ctor? id)
         (s/c-add! s/c-hash i/c-hash s/f-hash id ctc))))
    (s/o-make s/c-hash)))

;;
;; S/F-Hash functions
;;

;; A S/F-Hash is a [Hash Syntax [List-of Syntax]]
;; maps struct to its fields

;; Symbol Syntax -> S/F-hash
;; takes Typed Racket syntax and returns hash that maps struct names
;; to their fields
(define (s/f-make key stx)
  (define s/f-hash (make-hash))
  (let go ([stx stx])
    (syntax-parse stx
      #:datum-literals (struct struct: :)
      [((~or struct struct:) name ((fld : type) ...))
       #:when (equal? key 'provide)
       (hash-set! s/f-hash #'name (syntax-e #'(fld ...)))
       stx]
      [((~datum #:struct) name ((fld : type) ...))
       #:when (equal? key 'require-rename)
       (hash-set! s/f-hash #'name (syntax-e #'(fld ...)))
       stx]
      [(x ...)
       (for-each go (syntax-e #'(x ...)))
       stx]
      [_ stx]))
  s/f-hash)

;;
;; S/C-Hash functions
;;

;; A S/C-Hash is a [Hash Syntax [Hash Syntax Syntax]]
;; maps struct to its field-contract mapping

;; S/C-Hash I/C-Hash S/F-Hash Syntax Syntax -> Void
;; takes pair matching constructor with contract and pushes
;; appropriate field-to-contract association into s/c-hash
(define (s/c-add! s/c-hash i/c-hash s/f-hash id ctc)
  (let* ([id*      (unstrange s/f-hash id)]
         [fld-ctcs (chase-domain ctc i/c-hash)]
         [fld+ctcs (map cons
                        (hash-ref s/f-hash id*)
                        fld-ctcs)]
         [f/c-hash (make-hash fld+ctcs)])
    (hash-set! s/c-hash id* f/c-hash)))

;;
;; S/O-Hash functions
;;

;; A S/O-Hash is a [Hash Syntax Syntax]
;; maps struct to its struct-out declaration

;; Struct-Hash -> [List-of Syntax]
;; returns list of struct-out declarations for contract-out
(define (s/o-make s/c-hash)
  (hash-map
   s/c-hash
   (λ (name f/c-hash)
     #`(struct #,name #,(hash-map list f/c-hash)))))

;;
;; name helpers
;;

;; A Struct-Proc is a (Syntax [List-of Syntax] -> [List-of Syntax])
;; Returns some subset of all the exports generated by a
;; struct definition.

;; A Struct-Pred is a (Syntax -> Syntax or #f) that can determine
;; if an identifier a certain type of struct export and returns
;; the corresponding struct name or #f.

;; Struct-Pred defininitions

(define ((s/f-export? s/f-hash) id)
  (or (((struct-proc->struct-pred struct-exports) s/f-hash) id)
      (unstrange s/f-hash id)))
(define s/f-accessor?
  (struct-proc->struct-pred struct-accessors))
(define s/f-mutator?
  (struct-proc->struct-pred struct-mutators))

;; Struct-Proc definitions

(define (struct-exports id flds)
  (append (list id
                (format-id id "~a?" id)
                (format-id id "struct:~a" id))
          (struct-accessors id flds)
          (struct-mutators id flds)))

(define (struct-accessors id flds)
  (map (λ (fld) (format-id id "~a-~a" id fld))
       flds))

(define (struct-mutators id flds)
  (map (λ (fld) (format-id id "set-~a-~a!" id fld))
       flds))

;; Struct-Proc -> S/F-Hash -> Stuct-Pred
;; returns a predicate that can determine if an identifier is
;; that kind of export for the given mapping, returning which
;; struct it belonged to or #f
(define ((struct-proc->struct-pred sp) s/f-hash)
  (define exports
    (hash-map s/f-hash
              (λ (name flds)
                (map (λ (fld) (cons fld name))
                     (sp name flds)))))
  (define exports* (apply append exports))
  (dict->procedure exports* #:failure #f))

;;
;; other helpers
;;

;; Syntax I/C-Hash -> Syntax
;; returns domain of the given definition through
;; layers of definitional indirection
(define (chase-domain i i/c-hash)
  (syntax-parse i
    #:datum-literals (->)
    [(-> x ... _) (syntax-e #'(x ...))]
    [x            (chase-domain (hash-ref i/c-hash i) i/c-hash)]))

(define (unstrange s/f-hash id)
  (define id* (syntax->string id))
  (findf (λ (name)
           (define name* (syntax->string name))
           (or (string=? id* name*)
               (and (string-prefix? id* name*)
                    (string->number (substring id* (string-length name*))))))
         (hash-keys s/f-hash)))

;;
;; test helpers
;;

#;(module+ test
  (require rackunit)

  (define posn-hash
    (make-hash '((posn . (x y z)))))

  (test-case
    "extract-structs"
    (check-equal?
     (extract-structs
      'provide
      #'(module root typed/racket/base
          (struct: posn ((x : Real) (y : Real) (z : Real)))))
     posn-hash)

    (check-equal?
     (extract-structs
      'require-rename
      #'(module root typed/racket/base
          (require/typed/check "streams.rkt"
            [#:struct posn ([x : Real] [y : Real] [z : Real])])))
     posn-hash)
    )

  (test-case
    "struct-exports"
    (check-equal?
     (struct-exports 'posn '(x y z))
     '(posn
       posn?
       struct:posn
       posn-x posn-y posn-z
       set-posn-x! set-posn-y! set-posn-z!)))

  (define posn-export? (struct-export? posn-hash))
  (define posn-accessor? (struct-accessor? posn-hash))
  (define posn-mutator? (struct-mutator? posn-hash))

  (test-case
    "struct-export?"
    (check-equal? (posn-export? 'posn) 'posn)
    (check-equal? (posn-export? 'posn-x) 'posn)
    (check-false  (posn-export? 'posn-w))
    (check-equal? (posn-export? 'set-posn-y!) 'posn)
    (check-equal? (posn-export? 'posn?) 'posn)
    (check-equal? (posn-export? 'struct:posn) 'posn)
    )

  (test-case
    "struct-accessor?"
    (check-false  (posn-accessor? 'posn))
    (check-equal? (posn-accessor? 'posn-x) 'posn)
    (check-equal? (posn-accessor? 'posn-y) 'posn)
    (check-equal? (posn-accessor? 'posn-z) 'posn)
    (check-false  (posn-accessor? 'posn-w))
    (check-false (posn-accessor? 'set-posn-y!))
    (check-false (posn-accessor? 'posn?))
    (check-false (posn-accessor? 'struct:posn))
    )

  (test-case
    "struct-mutator?"
    (check-false  (posn-mutator? 'posn))
    (check-false (posn-mutator? 'posn-x))
    (check-false  (posn-mutator? 'posn-w))
    (check-equal? (posn-mutator? 'set-posn-x!) 'posn)
    (check-equal? (posn-mutator? 'set-posn-y!) 'posn)
    (check-equal? (posn-mutator? 'set-posn-z!) 'posn)
    (check-false (posn-mutator? 'posn?))
    (check-false (posn-mutator? 'struct:posn))
    )

  (test-case
    "struct-unstrange"
    (check-equal? (struct-unstrange posn-hash 'posn3) 'posn))
  )
