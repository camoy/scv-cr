#lang racket/base

(require racket/list
         racket/set
         racket/syntax
         racket/string
         racket/function
         mischief/dict
         syntax/parse
         scv-gt/private/syntax-util)

;; A Struct-Hash is a [Hash Symbol [Hash Syntax Syntax]]
;; mapping struct identifier to a mapping between fields
;; and contracts.

;; A Struct-Proc is a (Symbol [List-of Symbol] -> [List-of Symbol])
;; Returns some subset of all the exports generated by a
;; struct definition.

;;
;; struct munging
;;

(provide struct-munge!)

;; P/C-Hash I/C-Hash Syntax -> Syntax
;; takes an mapping between exports and contract definitions, the entire
;; program source, and mapping between
(define (struct-munge! p/c-hash i/c-hash kind stx-raw)
  (let* ([name->fields (extract-structs kind stx-raw)]
         [export?      (struct-export? name->fields)]
         [ctor?        (struct-ctor? name->fields)]
         [struct-hash  (make-hash)])
    (hash-for-each
     p/c-hash
     (位 (id ctc)
       (when (export? id)
         (hash-remove! p/c-hash id))
       (when (ctor? id)
         (struct-hash-add! struct-hash name->fields id ctc i/c-hash))))
    (values (make-struct-out stx-raw struct-hash)
            (hash-keys name->fields))))

;; Struct-Hash -> [List-of Syntax]
;; returns list of struct-out declarations for contract-out
(define (make-struct-out stx-raw struct-hash)
  (hash-map struct-hash
            (位 (name fld->ctc)
              #`(struct
                  #,(datum->syntax (syntax-fresh-scope stx-raw) name)
                  #,fld->ctc))))

;;
;; struct names
;;

;; Syntax -> [Hash Symbol [List-of Symbol]]
;; takes Typed Racket syntax and returns hash
;; that maps struct names to their fields
(define (extract-structs kind stx)
  (define name->fields
    (make-hash))
  (let go ([stx stx])
    (syntax-parse stx
      #:datum-literals (struct struct: :)
      [((~or struct struct:) name ((fld : type) ...))
       #:when (equal? kind 'provide)
       (hash-set! name->fields
                  (syntax-e #'name)
                  (syntax->datum #'(fld ...)))
       stx]
      [((~datum #:struct) name ((fld : type) ...))
       #:when (equal? kind 'require-rename)
       (hash-set! name->fields
                  (syntax-e #'name)
                  (syntax->datum #'(fld ...)))
       stx]
      [(x ...)
       (for-each go (syntax-e #'(x ...)))
       stx]
      [_ stx]))
  name->fields)

;; Struct-Proc
;; returns all exports
(define (struct-exports name flds)
  (append (list (format-symbol "~a?" name)
                (format-symbol "struct:~a" name))
          (struct-ctor name flds)
          (struct-accessors name flds)
          (struct-mutators name flds)))

;; Struct-Proc
;; returns only the accessors
(define (struct-accessors name flds)
  (map (curry format-symbol "~a-~a" name) flds))

;; Struct-Proc
;; returns only the mutators
(define (struct-mutators name flds)
  (map (curry format-symbol "set-~a-~a!" name) flds))

;; Struct-Proc
;; returns only the constructor
(define (struct-ctor name flds)
  (list name
        (format-symbol "~a3" name)))

;; Struct-Proc [Hash Symbol Symbol] -> (Symbol -> Symbol or #f)
;; takes a Struct-Proc and name field mapping and returns
;; a function that can determine if a symbol is that kind
;; of export for the given mapping
(define ((make-struct-proc? kind) name->fields)
  (define exports
    (hash-map name->fields
              (位 (name flds)
                (map (位 (fld) (cons fld name))
                     (kind name flds)))))
  (define exports* (apply append exports))
  (dict->procedure exports* #:failure #f))

(define struct-export? (make-struct-proc? struct-exports))
(define struct-accessor? (make-struct-proc? struct-accessors))
(define struct-mutator? (make-struct-proc? struct-mutators))
(define struct-ctor? (make-struct-proc? struct-ctor))

;;
;; struct munging helpers
;;

;; Syntax I/C-Hash -> Syntax
;; returns domain of the given definition through
;; layers of definitional indirection
(define (chase-domain i i/c-hash)
  (syntax-parse i
    #:datum-literals (->)
    [(-> x ... _) (syntax-e #'(x ...))]
    [x            (chase-domain (hash-ref i/c-hash
                                          (syntax-e i))
                                i/c-hash)]))

;; takes pair matching constructor with contract and pushes
;; appropriate field-to-contract association into struct
;; hash
(define (struct-hash-add! struct-hash name->fields id ctc i/c-hash)
  (let* ([id*      (unstrange id)]
         [fld-ctcs (chase-domain ctc i/c-hash)]
         [fld+ctcs (map list
                        (hash-ref name->fields id*)
                        fld-ctcs)])
    (hash-set! struct-hash id* fld+ctcs)))

(define (unstrange id)
  (define id* (symbol->string id))
  (if (string-suffix? id* "3")
      (string->symbol (substring id* 0 (sub1 (string-length id*))))
      id))
;;
;; test struct name
;;

(module+ test
  (require rackunit)

  (define posn-hash
    (make-hash '((posn . (x y z)))))

  (test-case
    "extract-structs"
    (check-equal?
     (extract-structs
      'provide
      #'(module root typed/racket/base
          (struct: posn ((x : Real) (y : Real) (z : Real)))))
     posn-hash)

    (check-equal?
     (extract-structs
      'require-rename
      #'(module root typed/racket/base
          (require/typed/check "streams.rkt"
            [#:struct posn ([x : Real] [y : Real] [z : Real])])))
     posn-hash)
    )

  (test-case
    "struct-exports"
    (check-equal?
     (struct-exports 'posn '(x y z))
     '(posn
       posn?
       struct:posn
       posn-x posn-y posn-z
       set-posn-x! set-posn-y! set-posn-z!)))

  (define posn-export? (struct-export? posn-hash))
  (define posn-accessor? (struct-accessor? posn-hash))
  (define posn-mutator? (struct-mutator? posn-hash))

  (test-case
    "struct-export?"
    (check-equal? (posn-export? 'posn) 'posn)
    (check-equal? (posn-export? 'posn-x) 'posn)
    (check-false  (posn-export? 'posn-w))
    (check-equal? (posn-export? 'set-posn-y!) 'posn)
    (check-equal? (posn-export? 'posn?) 'posn)
    (check-equal? (posn-export? 'struct:posn) 'posn)
    )

  (test-case
    "struct-accessor?"
    (check-false  (posn-accessor? 'posn))
    (check-equal? (posn-accessor? 'posn-x) 'posn)
    (check-equal? (posn-accessor? 'posn-y) 'posn)
    (check-equal? (posn-accessor? 'posn-z) 'posn)
    (check-false  (posn-accessor? 'posn-w))
    (check-false (posn-accessor? 'set-posn-y!))
    (check-false (posn-accessor? 'posn?))
    (check-false (posn-accessor? 'struct:posn))
    )

  (test-case
    "struct-mutator?"
    (check-false  (posn-mutator? 'posn))
    (check-false (posn-mutator? 'posn-x))
    (check-false  (posn-mutator? 'posn-w))
    (check-equal? (posn-mutator? 'set-posn-x!) 'posn)
    (check-equal? (posn-mutator? 'set-posn-y!) 'posn)
    (check-equal? (posn-mutator? 'set-posn-z!) 'posn)
    (check-false (posn-mutator? 'posn?))
    (check-false (posn-mutator? 'struct:posn))
    )
  )
