#lang typed/racket/base/no-check
(require racket/contract
          (lib "racket/contract.rkt")
          (lib "racket/base.rkt")
          (lib "racket/contract/base.rkt"))
(define g10 exact-integer?)
(define g11 (or/c g10))
(define g12 (listof g11))
(define generated-contract3 (-> g12 (values g12)))
(define generated-contract4 (-> g12 (values g12)))
(define generated-contract5 (-> (values g12)))
(define generated-contract6 (-> g12 (values g12)))
(define generated-contract7 (-> g12 (values g11 g12)))
(define generated-contract8 (-> g12 g11 (values g12)))
(define generated-contract9 (-> g12 (values g12)))
(provide (contract-out
           (stack-swap generated-contract9)
           (stack-push generated-contract8)
           (stack-pop generated-contract7)
           (stack-over generated-contract6)
           (stack-init generated-contract5)
           (stack-dup generated-contract4)
           (stack-drop generated-contract3)))
(module require/contracts racket/base
   (require racket/contract)
   (provide (contract-out)))
(require (prefix-in -: (only-in 'require/contracts))
          (except-in 'require/contracts))
(define-values () (values))
(provide)
(define-type Stack (Listof Integer))
(: list->stack (-> (Listof Integer) Stack))
(define (list->stack xs)
   (for/fold
    ((S : Stack (stack-init)))
    ((x : Integer (in-list (reverse xs))))
    (stack-push S x)))
(: stack-drop (-> Stack Stack))
(define (stack-drop S) (let-values (((_v S+) (stack-pop S))) S+))
(: stack-dup (-> Stack Stack))
(define (stack-dup S)
   (let-values (((v S+) (stack-pop S))) (stack-push (stack-push S+ v) v)))
(: stack-init (-> Stack))
(define (stack-init) '())
(: stack-over (-> Stack Stack))
(define (stack-over S)
   (let*-values (((v1 S1) (stack-pop S)) ((v2 S2) (stack-pop S1)))
     (stack-push (stack-push (stack-push S2 v1) v2) v1)))
(: stack-pop (-> Stack (Values Integer Stack)))
(define (stack-pop S)
   (if (null? S) (raise-user-error "empty stack") (values (car S) (cdr S))))
(: stack-push (-> Stack Integer Stack))
(define (stack-push S v) (cons v S))
(: stack-swap (-> Stack Stack))
(define (stack-swap S)
   (let*-values (((v1 S1) (stack-pop S)) ((v2 S2) (stack-pop S1)))
     (stack-push (stack-push S2 v1) v2)))
