(module datetime typed/racket/base/no-check
   (#%module-begin
    (require soft-contract/fake-contract
             (submod "gregor-structs.rkt" #%type-decl "..")
             (lib "typed-racket/types/numeric-predicates.rkt"))
    (define g26 (lambda (x) (Date? x)))
    (define g27 (lambda (x) (Time? x)))
    (define g28 (lambda (x) (DateTime? x)))
    (define g29 exact-nonnegative-integer?)
    (define g30 (or/c g29))
    (define g31 (lambda (x) (equal? x '1)))
    (define g32 (lambda (x) (equal? x '12)))
    (define g33 (lambda (x) (equal? x '11)))
    (define g34 (lambda (x) (equal? x '10)))
    (define g35 (lambda (x) (equal? x '9)))
    (define g36 (lambda (x) (equal? x '8)))
    (define g37 (lambda (x) (equal? x '7)))
    (define g38 (lambda (x) (equal? x '6)))
    (define g39 (lambda (x) (equal? x '5)))
    (define g40 (lambda (x) (equal? x '4)))
    (define g41 (lambda (x) (equal? x '3)))
    (define g42 (lambda (x) (equal? x '2)))
    (define g43 (or/c g31 g32 g33 g34 g35 g36 g37 g38 g39 g40 g41 g42))
    (define g44 string?)
    (define g45 exact-rational?)
    (define g46 (or/c g45))
    (define g47 exact-integer?)
    (define g48 (or/c g47))
    (define g49 '#t)
    (define g50 '#f)
    (define g51 (or/c g49 g50))
    (define g52 real?)
    (define g53 (or/c g52))
    (define generated-contract12 (-> g26 g27 (values g28)))
    (define generated-contract13
      (case->
       (-> g30 (values g28))
       (-> g30 g43 (values g28))
       (-> g30 g43 g30 (values g28))
       (-> g30 g43 g30 g30 (values g28))
       (-> g30 g43 g30 g30 g30 (values g28))
       (-> g30 g43 g30 g30 g30 g30 (values g28))
       (-> g30 g43 g30 g30 g30 g30 g30 (values g28))))
    (define generated-contract14 (-> g28 (values g26)))
    (define generated-contract15 (-> g28 (values g44)))
    (define generated-contract16 (-> g28 (values g46)))
    (define generated-contract17 (-> g28 (values g46)))
    (define generated-contract18 (-> g28 (values g27)))
    (define generated-contract19 (-> g28 g48 (values g28)))
    (define generated-contract20 (-> g28 g48 (values g28)))
    (define generated-contract21 (-> g28 g28 (values g51)))
    (define generated-contract22 (-> g28 g28 (values g51)))
    (define generated-contract23 (-> g28 g28 (values g51)))
    (define generated-contract24 (-> g53 (values g28)))
    (define generated-contract25 (-> g46 (values g28)))
    (module require/contracts racket/base
      (require soft-contract/fake-contract)
      (provide))
    (require (prefix-in -: (only-in 'require/contracts))
             (except-in 'require/contracts))
    (define-values () (values))
    (require require-typed-check
             "core-adapter.rkt"
             "gregor-adapter.rkt"
             racket/match
             (only-in racket/math exact-round exact-floor))
    (begin (require "hmsn.rkt") (void))
    (begin (require "date.rkt") (void))
    (begin (require "time.rkt") (void))
    (void)
    (: datetime-equal-proc (-> DateTime DateTime Boolean))
    (define (datetime-equal-proc x y) (= (datetime->jd x) (datetime->jd y)))
    (: datetime-hash-proc (-> DateTime (-> Exact-Rational Integer) Integer))
    (define (datetime-hash-proc x fn) (fn (datetime->jd x)))
    (: datetime-write-proc (-> DateTime Output-Port Any Void))
    (define (datetime-write-proc dt out mode)
      (fprintf out "#<datetime ~a>" (datetime->iso8601 dt)))
    (: datetime? (-> Any Boolean))
    (define datetime? DateTime?)
    (: datetime->date (-> DateTime Date))
    (define datetime->date DateTime-date)
    (: datetime->time (-> DateTime Time))
    (define datetime->time DateTime-time)
    (: datetime->jd (-> DateTime Exact-Rational))
    (define (datetime->jd d) (DateTime-jd d))
    (: datetime->posix (-> DateTime Exact-Rational))
    (define (datetime->posix dt) (jd->posix (datetime->jd dt)))
    (: posix->datetime (-> Exact-Rational DateTime))
    (define (posix->datetime posix)
      (jd->datetime (posix->jd (inexact->exact posix))))
    (: date+time->datetime (-> Date Time DateTime))
    (define (date+time->datetime d t) (DateTime d t (date+time->jd d t)))
    (: jd->datetime (-> Real DateTime))
    (define (jd->datetime jd)
      (define ejd (inexact->exact jd))
      (define-values (d t) (jd->date+time ejd))
      (date+time->datetime d t))
    (:
     datetime
     (->* (Natural) (Month Natural Natural Natural Natural Natural) DateTime))
    (define (datetime
             year
             (month 1)
             (day 1)
             (hour 0)
             (minute 0)
             (second 0)
             (nano 0))
      (date+time->datetime
       (date year month day)
       (make-time hour minute second nano)))
    (: datetime->iso8601 (-> DateTime String))
    (define (datetime->iso8601 dt)
      (format
       "~aT~a"
       (date->iso8601 (datetime->date dt))
       (time->iso8601 (datetime->time dt))))
    (: datetime=? (-> DateTime DateTime Boolean))
    (define (datetime=? dt1 dt2) (= (datetime->jd dt1) (datetime->jd dt2)))
    (: datetime<? (-> DateTime DateTime Boolean))
    (define (datetime<? dt1 dt2) (< (datetime->jd dt1) (datetime->jd dt2)))
    (: datetime<=? (-> DateTime DateTime Boolean))
    (define (datetime<=? dt1 dt2) (<= (datetime->jd dt1) (datetime->jd dt2)))
    (: date+time->jd (-> Date Time Exact-Rational))
    (define (date+time->jd d t)
      (define jdn (date->jdn d))
      (define day-ns (time->ns t))
      (+ (- jdn 1/2) (/ day-ns NS/DAY)))
    (: jd->date+time (-> Exact-Rational (Values Date Time)))
    (define (jd->date+time jd)
      (define jdn (jd->jdn jd))
      (define d (jdn->date jdn))
      (define day-ns (jd->day-ns jd))
      (define t (day-ns->time day-ns))
      (values d t))
    (: jd->jdn (-> Exact-Rational Integer))
    (define (jd->jdn jd)
      (define lo (exact-floor jd))
      (if (>= (- jd lo) 1/2) (add1 lo) lo))
    (: jd->day-ns (-> Exact-Rational Natural))
    (define (jd->day-ns jd)
      (define base (- jd 1/2))
      (define frac (- base (exact-floor base)))
      (define r (exact-round (* frac NS/DAY)))
      (unless (index? r) (error "jd->day-ns"))
      r)
    (: jd->posix (-> Exact-Rational Exact-Rational))
    (define (jd->posix jd) (* 86400 (- jd (+ 2440587 1/2))))
    (: posix->jd (-> Exact-Rational Exact-Rational))
    (define (posix->jd posix) (+ (/ posix 86400) (+ 2440587 1/2)))
    (: datetime-add-nanoseconds (-> DateTime Integer DateTime))
    (define (datetime-add-nanoseconds dt n)
      (jd->datetime (+ (datetime->jd dt) (/ n NS/DAY))))
    (: datetime-add-seconds (-> DateTime Integer DateTime))
    (define (datetime-add-seconds dt n)
      (datetime-add-nanoseconds dt (* n NS/SECOND)))
    (provide)
    (provide datetime<=?
             datetime<?
             datetime=?
             datetime-add-seconds
             datetime-add-nanoseconds
             datetime->iso8601
             posix->datetime
             jd->datetime
             date+time->datetime
             datetime->posix
             datetime->jd
             datetime->time
             datetime->date
             datetime)))
