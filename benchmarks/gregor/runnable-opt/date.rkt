(module date typed/racket/base/no-check
   (#%module-begin
    (require soft-contract/fake-contract
             (submod "core-structs.rkt" #%type-decl "..")
             (submod "gregor-structs.rkt" #%type-decl ".."))
    (define g59 exact-nonnegative-integer?)
    (define g60 (or/c g59))
    (define g61 (lambda (x) (equal? x '1)))
    (define g62 (lambda (x) (equal? x '2)))
    (define g63 (lambda (x) (equal? x '3)))
    (define g64 (lambda (x) (equal? x '4)))
    (define g65 (lambda (x) (equal? x '5)))
    (define g66 (lambda (x) (equal? x '6)))
    (define g67 (lambda (x) (equal? x '7)))
    (define g68 (lambda (x) (equal? x '8)))
    (define g69 (lambda (x) (equal? x '9)))
    (define g70 (lambda (x) (equal? x '10)))
    (define g71 (lambda (x) (equal? x '11)))
    (define g72 (lambda (x) (equal? x '12)))
    (define g73 (or/c g61 g62 g63 g64 g65 g66 g67 g68 g69 g70 g71 g72))
    (define g74 (lambda (x) (Date? x)))
    (define g75 string?)
    (define g76 exact-integer?)
    (define g77 (or/c g76))
    (define g78 (lambda (x) (YMD? x)))
    (define g79 '#t)
    (define g80 '#f)
    (define g81 (or/c g79 g80))
    (define generated-contract44
      (case->
       (-> g60 (values g74))
       (-> g60 g73 (values g74))
       (-> g60 g73 g60 (values g74))))
    (define generated-contract45 (-> g74 (values g60)))
    (define generated-contract46 (-> g74 (values g60)))
    (define generated-contract47 (-> g74 (values g75)))
    (define generated-contract48 (-> g74 (values g77)))
    (define generated-contract49 (-> g74 (values g78)))
    (define generated-contract50 (-> g74 g74 (values g81)))
    (define generated-contract51 (-> g74 g74 (values g81)))
    (define generated-contract52 (-> g77 (values g74)))
    (define generated-contract53 (-> g78 (values g74)))
    (module require/contracts racket/base
      (require soft-contract/fake-contract
               "fake-format.rkt"
               (lib "typed-racket/types/numeric-predicates.rkt"))
      (define g54 exact-rational?)
      (define g55 (or/c g54))
      (define g56 exact-nonnegative-integer?)
      (define g57 (or/c g56))
      (define g58 string?)
      (define l/1 (-> g55 g57 g58 (values g58)))
      (provide g55 g56 g57 g58 l/1 g54 (contract-out (~r l/1))))
    (require (prefix-in -: (only-in 'require/contracts ~r))
             (except-in 'require/contracts ~r))
    (define-values (~r) (values -:~r))
    (void)
    (require require-typed-check
             (only-in racket/math exact-round)
             "core-adapter.rkt"
             "gregor-adapter.rkt"
             racket/match)
    (begin (require "ymd.rkt") (void))
    (begin (void) (void))
    (: date-equal-proc (-> Date Date Boolean))
    (define (date-equal-proc x y) (= (Date-jdn x) (Date-jdn y)))
    (: date-hash-proc (-> Date (-> Integer Integer) Integer))
    (define (date-hash-proc x fn) (fn (Date-jdn x)))
    (: date-write-proc (-> Date Output-Port Any Void))
    (define (date-write-proc d out mode)
      (fprintf out "#<date ~a>" (date->iso8601 d)))
    (: date? (-> Any Boolean))
    (define date? Date?)
    (: date (->* (Natural) (Month Natural) Date))
    (define (date y (m 1) (d 1))
      (: ymd YMD)
      (define ymd (YMD y m d))
      (Date ymd (ymd->jdn ymd)))
    (: date->ymd (-> Date YMD))
    (define date->ymd Date-ymd)
    (: date->jdn (-> Date Integer))
    (define (date->jdn d) (Date-jdn d))
    (: ymd->date (-> YMD Date))
    (define (ymd->date ymd) (match-define (YMD y m d) ymd) (date y m d))
    (: jdn->date (-> Integer Date))
    (define (jdn->date jdn) (Date (jdn->ymd jdn) jdn))
    (: date->iso-week (-> Date Natural))
    (define (date->iso-week d) (car (date->iso-week+wyear d)))
    (: date->iso-wyear (-> Date Natural))
    (define (date->iso-wyear d) (cdr (date->iso-week+wyear d)))
    (: date->iso-week+wyear (-> Date (Pairof Natural Natural)))
    (define (date->iso-week+wyear d)
      (define ymd (date->ymd d))
      (define yday (ymd->yday ymd))
      (define iso-wday (jdn->iso-wday (date->jdn d)))
      (match-define (YMD y _ _) ymd)
      (define w (quotient (+ yday (- iso-wday) 10) 7))
      (cond
       ((zero? w)
        (define y-1
          (let ((r (sub1 y)))
            (unless (index? r) (error "date->iso-week+year"))
            r))
        (cons (iso-weeks-in-year y-1) y-1))
       ((and (= w 53) (> w (iso-weeks-in-year y))) (cons 1 (add1 y)))
       ((index? w) (cons w y))
       (else (error "date->iso-week+year"))))
    (: date->iso8601 (-> Date String))
    (define (date->iso8601 d)
      (: f (-> Integer Natural String))
      (define (f n len) (~r n len "0"))
      (match
       (Date-ymd d)
       ((YMD y m d) (format "~a-~a-~a" (f y 4) (f m 2) (f d 2)))))
    (: date=? (-> Date Date Boolean))
    (define (date=? d1 d2) (= (date->jdn d1) (date->jdn d2)))
    (: date<=? (-> Date Date Boolean))
    (define (date<=? d1 d2) (<= (date->jdn d1) (date->jdn d2)))
    (provide)
    (provide date<=?
             date=?
             date->iso8601
             date->iso-wyear
             date->iso-week
             jdn->date
             ymd->date
             date->jdn
             date->ymd
             date)))
