(module ymd typed/racket/base/no-check
   (#%module-begin
    (require soft-contract/fake-contract
             (lib "racket/contract.rkt")
             (lib "racket/base.rkt")
             (lib "racket/contract/base.rkt")
             (submod "core-structs.rkt" #%type-decl "..")
             (lib "typed-racket/types/numeric-predicates.rkt"))
    (define g62 exact-nonnegative-integer?)
    (define g63 (or/c g62))
    (define g64 (lambda (x) (equal? x '1)))
    (define g65 (lambda (x) (equal? x '12)))
    (define g66 (lambda (x) (equal? x '11)))
    (define g67 (lambda (x) (equal? x '10)))
    (define g68 (lambda (x) (equal? x '9)))
    (define g69 (lambda (x) (equal? x '8)))
    (define g70 (lambda (x) (equal? x '7)))
    (define g71 (lambda (x) (equal? x '6)))
    (define g72 (lambda (x) (equal? x '5)))
    (define g73 (lambda (x) (equal? x '4)))
    (define g74 (lambda (x) (equal? x '3)))
    (define g75 (lambda (x) (equal? x '2)))
    (define g76 (or/c g64 g65 g66 g67 g68 g69 g70 g71 g72 g73 g74 g75))
    (define g77 (lambda (x) (equal? x '31)))
    (define g78 (lambda (x) (equal? x '30)))
    (define g79 (lambda (x) (equal? x '29)))
    (define g80 (lambda (x) (equal? x '28)))
    (define g81 (or/c g77 g78 g79 g80))
    (define g82 (lambda (x) (equal? x '53)))
    (define g83 (lambda (x) (equal? x '52)))
    (define g84 (or/c g82 g83))
    (define g85 exact-integer?)
    (define g86 (or/c g85))
    (define g87 (or/c g64 g70 g71 g72 g73 g74 g75))
    (define g88 (lambda (x) (equal? x '0)))
    (define g89 (or/c g64 g88 g71 g72 g73 g74 g75))
    (define g90 t:exact-rational?)
    (define g91 (or/c g90))
    (define g92 (lambda (x) (YMD? x)))
    (define g93 '#t)
    (define g94 '#f)
    (define g95 (or/c g93 g94))
    (define g96 (or/c g64 g73 g74 g75))
    (define generated-contract51 (-> g63 g76 (values g81)))
    (define generated-contract52 (-> g63 (values g84)))
    (define generated-contract53 (-> g86 (values g87)))
    (define generated-contract54 (-> g86 (values g89)))
    (define generated-contract55 (-> g91 (values g92)))
    (define generated-contract56 (-> g63 (values g95)))
    (define generated-contract57 (-> g92 (values g86)))
    (define generated-contract58 (-> g92 (values g96)))
    (define generated-contract59 (-> g92 (values g63)))
    (define generated-contract60 (-> g92 g63 (values g92)))
    (define generated-contract61 (-> g92 g63 (values g92)))
    (module require/contracts racket/base
      (require soft-contract/fake-contract)
      (provide))
    (require (prefix-in -: (only-in 'require/contracts))
             (except-in 'require/contracts))
    (define-values () (values))
    (void)
    (require racket/match
             (only-in racket/math exact-truncate exact-floor)
             "core-adapter.rkt")
    (: div (-> Integer Integer Integer))
    (define (div x y)
      (define rem (remainder x y))
      (if (< (bitwise-xor rem y) 0) (sub1 (quotient x y)) (quotient x y)))
    (: mod (-> Integer Integer Integer))
    (define (mod x y)
      (define rem (remainder x y))
      (if (< (bitwise-xor rem y) 0) (+ rem y) rem))
    (: mod1 (-> Integer Integer Integer))
    (define (mod1 x y) (- y (mod (- y x) y)))
    (: ymd->jdn (-> YMD Integer))
    (define (ymd->jdn ymd)
      (match-define (YMD y m d) ymd)
      (let-values (((y m)
                    (if (< m 3) (values (sub1 y) (+ m 12)) (values y m))))
        (+
         d
         (exact-truncate (/ (- (* 153 m) 457) 5))
         (* 365 y)
         (exact-floor (/ y 4))
         (- (exact-floor (/ y 100)))
         (exact-floor (/ y 400))
         1721119)))
    (: jdn->ymd (-> Exact-Rational YMD))
    (define (jdn->ymd jdn)
      (let* ((x (exact-floor (/ (- jdn 1867216.25) 36524.25)))
             (a (+ jdn 1 x (- (exact-floor (/ x 4)))))
             (b (+ a 1524))
             (c (exact-floor (/ (- b 122.1) 365.25)))
             (d (exact-floor (* 365.25 c)))
             (e (exact-floor (/ (- b d) 30.6001)))
             (dom (- b d (exact-floor (* 30.6001 e)))))
        (let-values (((m y)
                      (if (<= e 13)
                        (values (sub1 e) (- c 4716))
                        (values (- e 13) (- c 4715)))))
          (unless (and
                   (index? y)
                   (and (index? m) (< 0 m) (< m 13))
                   (index? dom))
            (error "jdn->ymd"))
          (case m
            ((1) (YMD y 1 dom))
            ((2) (YMD y 2 dom))
            ((3) (YMD y 3 dom))
            ((4) (YMD y 4 dom))
            ((5) (YMD y 5 dom))
            ((6) (YMD y 6 dom))
            (else
             (case m
               ((7) (YMD y 7 dom))
               ((8) (YMD y 8 dom))
               ((9) (YMD y 9 dom))
               ((10) (YMD y 10 dom))
               ((11) (YMD y 11 dom))
               ((12) (YMD y 12 dom))
               (else (error "jdn->ymd"))))))))
    (: jdn->wday (-> Integer (U 0 1 2 3 4 5 6)))
    (define (jdn->wday jdn)
      (case (mod (add1 jdn) 7)
        ((0) 0)
        ((1) 1)
        ((2) 2)
        ((3) 3)
        ((4) 4)
        ((5) 5)
        ((6) 6)
        (else (error "jdn->wday"))))
    (: jdn->iso-wday (-> Integer (U 1 2 3 4 5 6 7)))
    (define (jdn->iso-wday jdn)
      (case (mod1 (jdn->wday jdn) 7)
        ((1) 1)
        ((2) 2)
        ((3) 3)
        ((4) 4)
        ((5) 5)
        ((6) 6)
        ((7) 7)
        (else (error "jdn->iso-wday"))))
    (: ymd->yday (-> YMD Natural))
    (define (ymd->yday ymd)
      (match-define (YMD y m d) ymd)
      (+
       d
       (if (leap-year? y)
         (vector-ref CUMULATIVE-MONTH-DAYS/LEAP (sub1 m))
         (vector-ref CUMULATIVE-MONTH-DAYS (sub1 m)))))
    (: ymd->quarter (-> YMD (U 1 2 3 4)))
    (define (ymd->quarter ymd)
      (case (add1 (quotient (sub1 (YMD-m ymd)) 3))
        ((1) 1)
        ((2) 2)
        ((3) 3)
        ((4) 4)
        (else (error "ymd->quarter"))))
    (: ymd-add-years (-> YMD Natural YMD))
    (define (ymd-add-years ymd n)
      (match-define (YMD y m d) ymd)
      (define ny (+ y n))
      (define max-dom (days-in-month ny m))
      (YMD ny m (if (<= d max-dom) d max-dom)))
    (: ymd-add-months (-> YMD Natural YMD))
    (define (ymd-add-months ymd n)
      (match-define (YMD y m d) ymd)
      (: ny Natural)
      (define ny
        (let ((r (+ y (div (+ m n -1) 12))))
          (unless (index? r) (error "ymd-add-months"))
          r))
      (define for-case (let ((v (mod1 (+ m n) 12))) (if (< v 0) (+ 12 v) v)))
      (: nm Month)
      (define nm
        (case for-case
          ((1) 1)
          ((2) 2)
          ((3) 3)
          ((4) 4)
          ((5) 5)
          ((6) 6)
          (else
           (case for-case
             ((7) 7)
             ((8) 8)
             ((9) 9)
             ((10) 10)
             ((11) 11)
             ((12) 12)
             (else (error "ymd-add-months"))))))
      (define max-dom (days-in-month ny nm))
      (define nd (if (<= d max-dom) d max-dom))
      (unless (index? nd) (error "ymd-add-months"))
      (case nm
        ((1) (YMD ny 1 nd))
        ((2) (YMD ny 2 nd))
        ((3) (YMD ny 3 nd))
        ((4) (YMD ny 4 nd))
        ((5) (YMD ny 5 nd))
        ((6) (YMD ny 6 nd))
        (else
         (case nm
           ((7) (YMD ny 7 nd))
           ((8) (YMD ny 8 nd))
           ((9) (YMD ny 9 nd))
           ((10) (YMD ny 10 nd))
           ((11) (YMD ny 11 nd))
           ((12) (YMD ny 12 nd))
           (else (error "ymd-add-months"))))))
    (: leap-year? (-> Natural Boolean))
    (define (leap-year? y)
      (and (zero? (remainder y 4))
           (or (not (zero? (remainder y 100))) (zero? (remainder y 400)))))
    (: days-in-month (-> Natural Month (U 28 29 30 31)))
    (define (days-in-month y m)
      (let ((delta (if (and (= m 2) (leap-year? y)) 1 0)))
        (case (+ (vector-ref DAYS-PER-MONTH m) delta)
          ((28) 28)
          ((29) 29)
          ((30) 30)
          ((31) 31)
          (else (error "days in month")))))
    (: iso-weeks-in-year (-> Natural (U 52 53)))
    (define (iso-weeks-in-year y)
      (define w (jdn->wday (ymd->jdn (YMD y 1 1))))
      (cond ((or (= w 4) (and (leap-year? y) (= w 3))) 53) (else 52)))
    (: DAYS-PER-MONTH (Vector 0 31 28 31 30 31 30 31 31 30 31 30 31))
    (define DAYS-PER-MONTH (vector 0 31 28 31 30 31 30 31 31 30 31 30 31))
    (:
     CUMULATIVE-MONTH-DAYS
     (Vector 0 31 59 90 120 151 181 212 243 273 304 334))
    (define CUMULATIVE-MONTH-DAYS
      (vector 0 31 59 90 120 151 181 212 243 273 304 334))
    (:
     CUMULATIVE-MONTH-DAYS/LEAP
     (Vector 0 31 60 91 121 152 182 213 244 274 305 335))
    (define CUMULATIVE-MONTH-DAYS/LEAP
      (vector 0 31 60 91 121 152 182 213 244 274 305 335))
    (provide)
    (provide (contract-out (jdn->ymd generated-contract55))
             (contract-out (ymd->jdn generated-contract57))
             (contract-out (iso-weeks-in-year generated-contract52))
             (contract-out (days-in-month generated-contract51))
             (contract-out (leap-year? generated-contract56))
             (contract-out (ymd-add-months generated-contract60))
             (contract-out (ymd-add-years generated-contract61))
             (contract-out (ymd->quarter generated-contract58))
             (contract-out (ymd->yday generated-contract59))
             (contract-out (jdn->iso-wday generated-contract53))
             (contract-out (jdn->wday generated-contract54)))))
