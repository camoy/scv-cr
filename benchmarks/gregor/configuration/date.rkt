(module date typed/racket/base/no-check
   (#%module-begin
    (require soft-contract/fake-contract
             (lib "racket/contract.rkt")
             (lib "racket/base.rkt")
             (submod "gregor-structs.rkt" #%type-decl "..")
             (lib "racket/contract/base.rkt")
             (submod "core-structs.rkt" #%type-decl ".."))
    (define g53 exact-nonnegative-integer?)
    (define g54 (or/c g53))
    (define g55 (lambda (x) (equal? x '1)))
    (define g56 (lambda (x) (equal? x '2)))
    (define g57 (lambda (x) (equal? x '3)))
    (define g58 (lambda (x) (equal? x '4)))
    (define g59 (lambda (x) (equal? x '5)))
    (define g60 (lambda (x) (equal? x '6)))
    (define g61 (lambda (x) (equal? x '7)))
    (define g62 (lambda (x) (equal? x '8)))
    (define g63 (lambda (x) (equal? x '9)))
    (define g64 (lambda (x) (equal? x '10)))
    (define g65 (lambda (x) (equal? x '11)))
    (define g66 (lambda (x) (equal? x '12)))
    (define g67 (or/c g55 g56 g57 g58 g59 g60 g61 g62 g63 g64 g65 g66))
    (define g68 (lambda (x) (Date? x)))
    (define g69 string?)
    (define g70 exact-integer?)
    (define g71 (or/c g70))
    (define g72 (lambda (x) (YMD? x)))
    (define g73 '#t)
    (define g74 '#f)
    (define g75 (or/c g73 g74))
    (define generated-contract43
      (case->
       (-> g54 (values g68))
       (-> g54 g67 (values g68))
       (-> g54 g67 g54 (values g68))))
    (define generated-contract44 (-> g68 (values g54)))
    (define generated-contract45 (-> g68 (values g54)))
    (define generated-contract46 (-> g68 (values g69)))
    (define generated-contract47 (-> g68 (values g71)))
    (define generated-contract48 (-> g68 (values g72)))
    (define generated-contract49 (-> g68 g68 (values g75)))
    (define generated-contract50 (-> g68 g68 (values g75)))
    (define generated-contract51 (-> g71 (values g68)))
    (define generated-contract52 (-> g72 (values g68)))
    (module require/contracts racket/base
      (require soft-contract/fake-contract)
      (provide))
    (require (prefix-in -: (only-in 'require/contracts))
             (except-in 'require/contracts))
    (define-values () (values))
    (void)
    (require require-typed-check
             (only-in racket/math exact-round)
             "format-adapter.rkt"
             "core-adapter.rkt"
             "gregor-adapter.rkt"
             racket/match)
    (begin (require "ymd.rkt") (void))
    (: date-equal-proc (-> Date Date Boolean))
    (define (date-equal-proc x y) (= (Date-jdn x) (Date-jdn y)))
    (: date-hash-proc (-> Date (-> Integer Integer) Integer))
    (define (date-hash-proc x fn) (fn (Date-jdn x)))
    (: date-write-proc (-> Date Output-Port Any Void))
    (define (date-write-proc d out mode)
      (fprintf out "#<date ~a>" (date->iso8601 d)))
    (: date? (-> Any Boolean))
    (define date? Date?)
    (: date (->* (Natural) (Month Natural) Date))
    (define (date y (m 1) (d 1))
      (: ymd YMD)
      (define ymd (YMD y m d))
      (Date ymd (ymd->jdn ymd)))
    (: date->ymd (-> Date YMD))
    (define date->ymd Date-ymd)
    (: date->jdn (-> Date Integer))
    (define (date->jdn d) (Date-jdn d))
    (: ymd->date (-> YMD Date))
    (define (ymd->date ymd) (match-define (YMD y m d) ymd) (date y m d))
    (: jdn->date (-> Integer Date))
    (define (jdn->date jdn) (Date (jdn->ymd jdn) jdn))
    (: date->iso-week (-> Date Natural))
    (define (date->iso-week d) (car (date->iso-week+wyear d)))
    (: date->iso-wyear (-> Date Natural))
    (define (date->iso-wyear d) (cdr (date->iso-week+wyear d)))
    (: date->iso-week+wyear (-> Date (Pairof Natural Natural)))
    (define (date->iso-week+wyear d)
      (define ymd (date->ymd d))
      (define yday (ymd->yday ymd))
      (define iso-wday (jdn->iso-wday (date->jdn d)))
      (match-define (YMD y _ _) ymd)
      (define w (quotient (+ yday (- iso-wday) 10) 7))
      (cond
       ((zero? w)
        (define y-1
          (let ((r (sub1 y)))
            (unless (index? r) (error "date->iso-week+year"))
            r))
        (cons (iso-weeks-in-year y-1) y-1))
       ((and (= w 53) (> w (iso-weeks-in-year y))) (cons 1 (add1 y)))
       ((index? w) (cons w y))
       (else (error "date->iso-week+year"))))
    (: date->iso8601 (-> Date String))
    (define (date->iso8601 d)
      (: f (-> Integer Natural String))
      (define (f n len) (~r n len "0"))
      (match
       (Date-ymd d)
       ((YMD y m d) (format "~a-~a-~a" (f y 4) (f m 2) (f d 2)))))
    (: date=? (-> Date Date Boolean))
    (define (date=? d1 d2) (= (date->jdn d1) (date->jdn d2)))
    (: date<=? (-> Date Date Boolean))
    (define (date<=? d1 d2) (<= (date->jdn d1) (date->jdn d2)))
    (provide)
    (provide (contract-out (date<=? generated-contract49))
             (contract-out (date=? generated-contract50))
             (contract-out (date->iso8601 generated-contract46))
             (contract-out (date->iso-wyear generated-contract45))
             (contract-out (date->iso-week generated-contract44))
             (contract-out (jdn->date generated-contract51))
             (contract-out (ymd->date generated-contract52))
             (contract-out (date->jdn generated-contract47))
             (contract-out (date->ymd generated-contract48))
             (contract-out (date generated-contract43)))))
