(module time typed/racket/base/no-check
   (#%module-begin
    (require soft-contract/fake-contract
             (lib "racket/contract.rkt")
             (lib "racket/base.rkt")
             (lib "racket/contract/base.rkt")
             (submod "gregor-structs.rkt" #%type-decl "..")
             (submod "core-structs.rkt" #%type-decl ".."))
    (define g31 exact-nonnegative-integer?)
    (define g32 (or/c g31))
    (define g33 (lambda (x) (Time? x)))
    (define g34 exact-integer?)
    (define g35 (or/c g34))
    (define g36 (lambda (x) (HMSN? x)))
    (define g37 string?)
    (define g38 '#t)
    (define g39 '#f)
    (define g40 (or/c g38 g39))
    (define generated-contract23 (-> g32 (values g33)))
    (define generated-contract24
      (case->
       (-> g35 (values g33))
       (-> g35 g35 (values g33))
       (-> g35 g35 g35 (values g33))
       (-> g35 g35 g35 g35 (values g33))))
    (define generated-contract25 (-> g33 (values g36)))
    (define generated-contract26 (-> g33 (values g37)))
    (define generated-contract27 (-> g33 (values g32)))
    (define generated-contract28 (-> g33 g33 (values g40)))
    (define generated-contract29 (-> g33 g33 (values g40)))
    (define generated-contract30 (-> g33 g33 (values g40)))
    (module require/contracts racket/base
      (require soft-contract/fake-contract)
      (provide))
    (require (prefix-in -: (only-in 'require/contracts))
             (except-in 'require/contracts))
    (define-values () (values))
    (void)
    (require require-typed-check
             "format-adapter.rkt"
             "core-adapter.rkt"
             "gregor-adapter.rkt"
             racket/match)
    (begin (require "hmsn.rkt") (void))
    (: time-equal-proc (-> Time Time Boolean))
    (define (time-equal-proc x y) (= (Time-ns x) (Time-ns y)))
    (: time-hash-proc (-> Time (-> Natural Integer) Integer))
    (define (time-hash-proc x fn) (fn (Time-ns x)))
    (: time-write-proc (-> Time Output-Port Any Void))
    (define (time-write-proc t out mode)
      (fprintf out "#<time ~a>" (time->iso8601 t)))
    (: time? (-> Any Boolean))
    (define time? Time?)
    (: time->hmsn (-> Time HMSN))
    (define time->hmsn Time-hmsn)
    (: time->ns (-> Time Natural))
    (define (time->ns t) (Time-ns t))
    (: hmsn->time (-> HMSN Time))
    (define (hmsn->time hmsn) (Time hmsn (hmsn->day-ns hmsn)))
    (: day-ns->time (-> Natural Time))
    (define (day-ns->time ns) (Time (day-ns->hmsn ns) ns))
    (: make-time (->* (Integer) (Integer Integer Integer) Time))
    (define (make-time h (m 0) (s 0) (n 0)) (hmsn->time (HMSN h m s n)))
    (: time->iso8601 (-> Time String))
    (define (time->iso8601 t)
      (: f (-> Integer Natural String))
      (define (f n l) (~r n l "0"))
      (match-define (HMSN h m s n) (time->hmsn t))
      (define fsec (+ s (/ n NS/SECOND)))
      (define pad (if (>= s 10) "" "0"))
      (format "~a:~a:~a~a" (f h 2) (f m 2) pad (~r* fsec 9)))
    (: time=? (-> Time Time Boolean))
    (define (time=? t1 t2) (= (time->ns t1) (time->ns t2)))
    (: time<=? (-> Time Time Boolean))
    (define (time<=? t1 t2) (<= (time->ns t1) (time->ns t2)))
    (: time<? (-> Time Time Boolean))
    (define (time<? t1 t2) (< (time->ns t1) (time->ns t2)))
    (provide)
    (provide (contract-out (time<=? generated-contract28))
             (contract-out (time<? generated-contract29))
             (contract-out (time=? generated-contract30))
             (contract-out (time->iso8601 generated-contract26))
             (contract-out (day-ns->time generated-contract23))
             (contract-out (time->ns generated-contract27))
             (contract-out (time->hmsn generated-contract25))
             (contract-out (make-time generated-contract24)))))
