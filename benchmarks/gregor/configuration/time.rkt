(module time typed/racket/base/no-check
   (#%module-begin
    (require soft-contract/fake-contract
             (lib "racket/contract/base.rkt")
             (lib "racket/base.rkt")
             (lib "racket/contract.rkt")
             (submod "core-structs.rkt" #%type-decl "..")
             (submod "gregor-structs.rkt" #%type-decl ".."))
    (define g38 exact-nonnegative-integer?)
    (define g39 (or/c g38))
    (define g40 (lambda (x) (Time? x)))
    (define g41 exact-integer?)
    (define g42 (or/c g41))
    (define g43 (lambda (x) (HMSN? x)))
    (define g44 string?)
    (define g45 '#t)
    (define g46 '#f)
    (define g47 (or/c g45 g46))
    (define generated-contract30 (-> g39 (values g40)))
    (define generated-contract31
      (case->
       (-> g42 (values g40))
       (-> g42 g42 (values g40))
       (-> g42 g42 g42 (values g40))
       (-> g42 g42 g42 g42 (values g40))))
    (define generated-contract32 (-> g40 (values g43)))
    (define generated-contract33 (-> g40 (values g44)))
    (define generated-contract34 (-> g40 (values g39)))
    (define generated-contract35 (-> g40 g40 (values g47)))
    (define generated-contract36 (-> g40 g40 (values g47)))
    (define generated-contract37 (-> g40 g40 (values g47)))
    (module require/contracts racket/base
      (require soft-contract/fake-contract)
      (provide))
    (require (prefix-in -: (only-in 'require/contracts))
             (except-in 'require/contracts))
    (define-values () (values))
    (void)
    (require require-typed-check
             (only-in racket/format ~r)
             "core-adapter.rkt"
             "gregor-adapter.rkt"
             racket/match)
    (begin (require "hmsn.rkt") (void))
    (: time-equal-proc (-> Time Time Boolean))
    (define (time-equal-proc x y) (= (Time-ns x) (Time-ns y)))
    (: time-hash-proc (-> Time (-> Natural Integer) Integer))
    (define (time-hash-proc x fn) (fn (Time-ns x)))
    (: time-write-proc (-> Time Output-Port Any Void))
    (define (time-write-proc t out mode)
      (fprintf out "#<time ~a>" (time->iso8601 t)))
    (: time? (-> Any Boolean))
    (define time? Time?)
    (: time->hmsn (-> Time HMSN))
    (define time->hmsn Time-hmsn)
    (: time->ns (-> Time Natural))
    (define (time->ns t) (Time-ns t))
    (: hmsn->time (-> HMSN Time))
    (define (hmsn->time hmsn) (Time hmsn (hmsn->day-ns hmsn)))
    (: day-ns->time (-> Natural Time))
    (define (day-ns->time ns) (Time (day-ns->hmsn ns) ns))
    (: make-time (->* (Integer) (Integer Integer Integer) Time))
    (define (make-time h (m 0) (s 0) (n 0)) (hmsn->time (HMSN h m s n)))
    (: time->iso8601 (-> Time String))
    (define (time->iso8601 t)
      (: f (-> Integer Natural String))
      (define (f n l) (~r n #:min-width l #:pad-string "0"))
      (match-define (HMSN h m s n) (time->hmsn t))
      (define fsec (+ s (/ n NS/SECOND)))
      (define pad (if (>= s 10) "" "0"))
      (format "~a:~a:~a~a" (f h 2) (f m 2) pad (~r fsec #:precision 9)))
    (: time=? (-> Time Time Boolean))
    (define (time=? t1 t2) (= (time->ns t1) (time->ns t2)))
    (: time<=? (-> Time Time Boolean))
    (define (time<=? t1 t2) (<= (time->ns t1) (time->ns t2)))
    (: time<? (-> Time Time Boolean))
    (define (time<? t1 t2) (< (time->ns t1) (time->ns t2)))
    (provide)
    (provide (contract-out (day-ns->time generated-contract30))
             (contract-out (time->ns generated-contract34))
             (contract-out (time->hmsn generated-contract32))
             (contract-out (make-time generated-contract31))
             (contract-out (time<=? generated-contract35))
             (contract-out (time<? generated-contract36))
             (contract-out (time=? generated-contract37))
             (contract-out (time->iso8601 generated-contract33)))))
