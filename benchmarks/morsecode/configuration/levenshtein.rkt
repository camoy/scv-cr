(module levenshtein typed/racket/base/no-check
   (#%module-begin
    (require racket/contract
             (lib "racket/contract/base.rkt")
             (lib "racket/base.rkt")
             (lib "racket/contract.rkt")
             (lib "typed-racket/types/numeric-predicates.rkt"))
    (define g16 string?)
    (define g17 char?)
    (define g18 (listof g17))
    (define g19 (vectorof g17))
    (define g20 (or/c g16 g18 g19))
    (define g21 t:index?)
    (define g22 (or/c g21))
    (define g23 '#t)
    (define g24 '#f)
    (define g25 (or/c g23 g24))
    (define g26 (-> g17 g17 (values g25)))
    (define g27 (or/c g19))
    (define g28 exact-integer?)
    (define g29 (or/c g28))
    (define g30 (vectorof g22))
    (define g31 (or/c g30))
    (define g32 (-> g29 (values g31)))
    (define generated-contract3 (-> g20 g20 (values g22)))
    (define generated-contract4 (-> g18 g18 (values g22)))
    (define generated-contract5 (-> g18 g18 (values g22)))
    (define generated-contract6 (-> g18 g18 (values g22)))
    (define generated-contract7 (-> g18 g18 (values g22)))
    (define generated-contract8 (-> g18 g18 g26 (values g22)))
    (define generated-contract9 (-> g16 g16 (values g22)))
    (define generated-contract10 (-> g27 g27 (values g22)))
    (define generated-contract11 (-> g27 g27 (values g22)))
    (define generated-contract12 (-> g27 g27 (values g22)))
    (define generated-contract13 (-> g27 g27 (values g22)))
    (define generated-contract14 (-> g27 g27 g26 (values g22)))
    (define generated-contract15 (-> g27 g27 g26 g32 (values g22)))
    (module require/contracts racket/base (require racket/contract) (provide))
    (require (prefix-in -: (only-in 'require/contracts))
             (except-in 'require/contracts))
    (define-values () (values))
    (: %identity (All (A) (-> A A)))
    (define (%identity x) x)
    (: %string-empty? (-> String Boolean))
    (define (%string-empty? v) (zero? (string-length v)))
    (: %vector-empty? (-> (Vectorof Char) Boolean))
    (define (%vector-empty? v) (zero? (vector-length v)))
    (: %string->vector (-> String (Vectorof Char)))
    (define (%string->vector s) (list->vector (string->list s)))
    (:
     vector-levenshtein/predicate/get-scratch
     (->
      (Vectorof Char)
      (Vectorof Char)
      (-> Char Char Boolean)
      (-> Integer (Vectorof Index))
      Index))
    (define (vector-levenshtein/predicate/get-scratch a b pred get-scratch)
      (let:
       ((a-len : Index (vector-length a)) (b-len : Index (vector-length b)))
       (cond
        ((zero? a-len) b-len)
        ((zero? b-len) a-len)
        (else
         (let:
          ((w : (Vectorof Index) (get-scratch (+ 1 b-len))) (next : Index 0))
          (let fill ((k b-len))
            (unless (index? k) (error "vl/p/g invariant error"))
            (vector-set! w k k)
            (or (zero? k) (fill (- k 1))))
          (let loop-i ((i 0))
            (if (= i a-len)
              next
              (let ((a-i (vector-ref a i)))
                (let loop-j ((j 0) (cur (+ 1 i)))
                  (if (= j b-len)
                    (begin (vector-set! w b-len next) (loop-i (+ 1 i)))
                    (let ((next*
                           (min
                            (+ 1 (vector-ref w (+ 1 j)))
                            (+ 1 cur)
                            (if (pred a-i (vector-ref b j))
                              (vector-ref w j)
                              (+ 1 (vector-ref w j))))))
                      (unless (index? next*) (error "invariant"))
                      (set! next next*)
                      (unless (index? cur) (error "invariant error"))
                      (vector-set! w j cur)
                      (loop-j (+ 1 j) next))))))))))))
    (:
     vector-levenshtein/predicate
     (-> (Vectorof Char) (Vectorof Char) (-> Char Char Boolean) Index))
    (define (vector-levenshtein/predicate a b pred)
      (vector-levenshtein/predicate/get-scratch a b pred make-vector))
    (: vector-levenshtein/eq (-> (Vectorof Char) (Vectorof Char) Index))
    (define (vector-levenshtein/eq a b) (vector-levenshtein/predicate a b eq?))
    (: vector-levenshtein/eqv (-> (Vectorof Char) (Vectorof Char) Index))
    (define (vector-levenshtein/eqv a b)
      (vector-levenshtein/predicate a b eqv?))
    (: vector-levenshtein/equal (-> (Vectorof Char) (Vectorof Char) Index))
    (define (vector-levenshtein/equal a b)
      (vector-levenshtein/predicate a b equal?))
    (: vector-levenshtein (-> (Vectorof Char) (Vectorof Char) Index))
    (define (vector-levenshtein a b) (vector-levenshtein/equal a b))
    (:
     list-levenshtein/predicate
     (-> (Listof Char) (Listof Char) (-> Char Char Boolean) Index))
    (define (list-levenshtein/predicate a b pred)
      (cond
       ((null? a) (length b))
       ((null? b) (length a))
       (else
        (vector-levenshtein/predicate
         (list->vector a)
         (list->vector b)
         pred))))
    (: list-levenshtein/eq (-> (Listof Char) (Listof Char) Index))
    (define (list-levenshtein/eq a b) (list-levenshtein/predicate a b eq?))
    (: list-levenshtein/eqv (-> (Listof Char) (Listof Char) Index))
    (define (list-levenshtein/eqv a b) (list-levenshtein/predicate a b eqv?))
    (: list-levenshtein/equal (-> (Listof Char) (Listof Char) Index))
    (define (list-levenshtein/equal a b)
      (list-levenshtein/predicate a b equal?))
    (: list-levenshtein (-> (Listof Char) (Listof Char) Index))
    (define (list-levenshtein a b) (list-levenshtein/equal a b))
    (: string-levenshtein (-> String String Index))
    (define (string-levenshtein a b)
      (cond
       ((zero? (string-length a)) (string-length b))
       ((zero? (string-length b)) (string-length a))
       (else
        (vector-levenshtein/eqv (%string->vector a) (%string->vector b)))))
    (:
     %string-levenshtein/predicate
     (-> String String (-> Char Char Boolean) Index))
    (define (%string-levenshtein/predicate a b pred)
      (cond
       ((zero? (string-length a)) (string-length b))
       ((zero? (string-length b)) (string-length a))
       (else
        (vector-levenshtein/predicate
         (%string->vector a)
         (%string->vector b)
         pred))))
    (define-type LType (U (Vectorof Char) String (Listof Char)))
    (: levenshtein (-> LType LType Index))
    (define (levenshtein a b)
      (cond
       ((and (string? a) (string? b)) (string-levenshtein a b))
       ((and (vector? a) (vector? b)) (vector-levenshtein a b))
       ((and (list? a) (list? b)) (list-levenshtein a b))
       (else (error "levenshtein"))))
    (void)
    (provide)
    (provide (contract-out (string-levenshtein generated-contract9))
             (contract-out (vector-levenshtein/eqv generated-contract13))
             (contract-out (vector-levenshtein generated-contract10))
             (contract-out (vector-levenshtein/predicate generated-contract14))
             (contract-out (vector-levenshtein/eq generated-contract11))
             (contract-out
              (vector-levenshtein/predicate/get-scratch generated-contract15))
             (contract-out (vector-levenshtein/equal generated-contract12))
             (contract-out (list-levenshtein/eq generated-contract5))
             (contract-out (list-levenshtein/equal generated-contract6))
             (contract-out (levenshtein generated-contract3))
             (contract-out (list-levenshtein/eqv generated-contract7))
             (contract-out (list-levenshtein generated-contract4))
             (contract-out (list-levenshtein/predicate generated-contract8)))))
